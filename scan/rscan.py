# initialized by ByWaf upon plugin load
# FIXME:  Does this need to be here explicitly?
app = None

# required dictionary
options = {
   # <name>             <value>    <default value>   <required>  <description>
  'TIMEOUT':            ('',       '2',              'No',        'Default timeouts on queries'),
  'NETWORK':            ('',       '192.168.0.0/24', 'Yes',       'IPv4 or IPv6 network segment in CIDR notation')
  }


"initializing testDB plugin"
from itertools import count

import time

# from python 3, available in python2 via 'pip'
import ipaddr

#from scapy.all import *
import nmap

# ------------
# Plugin commands

def do_scan(*_):
    """scan according to plugin parameters"""
    subnet_string = options['NETWORK'].current_value  # this index yields an Option type, from bywaf.py
    app.print_line('scanning network {}'.format(subnet_string))
    session = app.db.get_session()
    
   
    # create an IP Network iterable.  If the source IP host or network address is invalid, 
    # an exception is generated by IPNetwork() and caught here.
    try:
        subnet = ipaddr.IPNetwork(subnet_string)
    except ValueError:  # ip_network() didn't like the input string
        app.print_line('error! subnet string "{}" appears to be invalid!'.format(subnet_string))
        return
 
    # iterate over the counter, scanning hosts
    for _hostip in subnet:
        hostip = str(_hostip)

        # place values into host database
        try:
            nm = nmap.PortScanner()         # instantiate nmap.PortScanner object
            nm.scan('/'.join([str(hostip),'32']), '1-443') # FIXME:  Make the portrange more dynamic
            
        except Exception as e:
            app.print_line("rscan.do_scan in adding a new host: got exception: {!r};".format(e))
            return None
            
        if nm[hostip].state()=='up':
            
            new_host = app.db.Host.add(session=session, hostip=hostip, hostname='')









            # add TCP ports to the database
            for p in nm[hostip].all_tcp(): # all_tcp() returns a list of integers denoting TCP ports
#                if nm.tcp(p)['state']=='open': # add open TCP ports to the database
                    app.print_line('adding port {} (tcp) to host {}'.format(p, hostip))
                    try:
                        app.db.Port.add(session, protocol='TCP', port_number=p, status=nm[hostip].tcp(p)['state'], hostid=hostip)
                    except Exception as e:
                        app.print_line("rscan.do_scan adding TCP(): got exception: {!r};".format(e))
                        session.rollback()
            
            # add UDP ports to the database
            for p in nm[hostip].all_udp(): # all_udp() returns a list of integers denoting UDP ports
#                if nm.udp(p)['state']=='open': # add open UDP ports to the database
                    app.print_line('adding port {} (tcp) to host {}'.format(p, hostip))
                    try:
                        app.db.Port.add(session, protocol='UDP', port_number=p, status=nm[hostip].udp(p)['state'], hostid=hostip)
                    except Exception as e:
                        app.print_line("rscan.do_scan adding UDP(): got exception: {!r};".format(e))
                        session.rollback()                

                    
def do_count_hosts(*_):
    """print a count of hosts in the database"""
    
    session = app.db.get_session()
    app.print_line('{} hosts in the database'.format(app.db.Host.count(session)))

    
# ----------
# Internal functions

def scan_host(hostip=''):
    app.print_line('NMap-scanning host {}'.format(hostip))
    
    try:
        nm = nmap.PortScanner()         # instantiate nmap.PortScanner object
        nm.scan('/'.join([str(hostip),'32']), '1-443') # FIXME:  Make the portrange more dynamic
    except Exception as e:
            app.print_line("scan_host(): got exception: {!r};".format(e))
            return
 
    return nm # return an NMap scan result object

            
